#include<glut/glut.h>

#include <iostream>

#include <cmath>

#include <cstring>



using namespace std;



void myInit() {

    glClearColor(1.0,1.0,1.0,0.0);

    glColor3f(0.0f,0.0f,0.0f);

    glPointSize(10);

    glMatrixMode(GL_PROJECTION);

    glLoadIdentity();

    gluOrtho2D(-10.0,10.0,-10.0,10.0);

}





void Points()

{

    //glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_POINTS);

    glVertex2d(150,100);

    glVertex2d(100,230);

    glVertex2d(170,130);

    glVertex2d(300,350);

    glEnd();

    glFlush();

}





void DDA()

{

    

    glClear(GL_COLOR_BUFFER_BIT);

    

    glRasterPos2f(2.0f,-10.0f);

    

    char* string="(0,0)";

    for (char* c = string; *c != '\0'; c++)

            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

    

    glLineWidth(2);

    glPointSize(7);

    glBegin(GL_LINES);

    glVertex3f(-320.0f,0.0f,0.0f);

    glVertex3f(320.0f,0.0f,0.0f);

    glEnd();

    

    glLineWidth(2);

    glBegin(GL_LINES);

    glVertex3f(0.0f,-240.0f,0.0f);

    glVertex3f(0.0f,240.0f,0.0f);

    glEnd();

    

    

    

    float xa=4,ya=7,xb=7,yb=3;

    

    glLineWidth(2);

    glBegin(GL_LINES);

    glVertex3f(xa,ya,0.0f);

    glVertex3f(xb,yb,0.0f);

    glEnd();

    

    float m=(yb-ya)/(xb-xa);

    

    float x, y;

    

    //glBegin(GL_POINTS);

    

    int choice=1;

    

    if(m>0 && m<=1)

    {

        if(choice==1)

        {

            x=xa;

            y=ya;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xb) && y!=round(yb))

            {

                x=x+1;

                y=y+m;

                

                glRasterPos2f(x,y+0.5);

                

                std::string string;

                

                string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

                

                char *s=const_cast<char*>(string.c_str());

                

                for (char* c = s; *c != '\0'; c++)

                        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

                

                glBegin(GL_POINTS);

                glVertex2f(x,round(y));

                glEnd();

            }

        }

        else if(choice==2)

        {

            x=xb;

            y=yb;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xa) && y!=round(ya))

            {

                x=x-1;

                y=y-m;

                

                glBegin(GL_POINTS);

                glVertex2f(x,round(y));

                glEnd();

            }

        }

    }

    else if(m>1)

    {

        if(choice==1)

        {

            x=xa;

            y=ya;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xb) && y!=round(yb))

            {

                x=x+(1/m);

                y=y+1;

                

                glBegin(GL_POINTS);

                glVertex2f(round(x),y);

                glEnd();

            }

        }

        else if(choice==2)

        {

            x=xb;

            y=yb;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xa) && y!=round(ya))

            {

                x=x-(1/m);

                y=y-1;

                

                glBegin(GL_POINTS);

                glVertex2f(round(x),y);

                glEnd();

            }

        }

    }

    else if(m<0 && m>=-1)

    {

        if(choice==1)

        {

            x=xa;

            y=ya;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xb) && y!=round(yb))

            {

                x=x+1;

                y=y-abs(m);

                

                glBegin(GL_POINTS);

                glVertex2f(x,round(y));

                glEnd();

            }

        }

        else if(choice==2)

        {

            x=xb;

            y=yb;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xa) && y!=round(ya))

            {

                x=x-1;

                y=y+abs(m);

                

                glBegin(GL_POINTS);

                glVertex2f(x,round(y));

                glEnd();

            }

        }

    }

    else if(m<=-1)

    {

        if(choice==1)

        {

            x=xa;

            y=ya;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xb) && y!=round(yb))

            {

                x=x+abs((1/m));

                y=y-1;

                

                glBegin(GL_POINTS);

                glVertex2f(round(x),y);

                glEnd();

            }

        }

        else if(choice==2)

        {

            x=xb;

            y=yb;

            

            glBegin(GL_POINTS);

            glVertex2f(x,y);

            glEnd();

            

            glRasterPos2f(x,y+1);

            

            std::string string;

            

            string="("+std::to_string(int(round(x)))+","+std::to_string(int(round(y)))+")";

            

            char *s=const_cast<char*>(string.c_str());

            

            for (char* c = s; *c != '\0'; c++)

                    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_10 , *c);

            

            while(x!=round(xa) && y!=round(ya))

            {

                x=x-abs((1/m));

                y=y+1;

                

                glBegin(GL_POINTS);

                glVertex2f(round(x),y);

                glEnd();

            }

        }

    }

    

    //glEnd();

    glFlush();

}







int main(int argc,char* argv[])

{

    glutInit(&argc,argv);

    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);

    glutInitWindowSize(640,480);

    glutCreateWindow("First Exercise");

    glutDisplayFunc(DDA);

    myInit();

    glutMainLoop();

    return 1;

}

